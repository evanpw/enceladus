---- Declarations for built-in functions written in C

-- String functions
type Char = Int
type String = [Char]

-- I/O functions
foreign read :: Int
foreign readLine :: String
foreign print :: String -> Unit
foreign dieWithMessage :: String -> Unit

-- Tree functions
-- foreign Node :: Int -> Tree -> Tree -> Tree
data Tree = Node Int Tree Tree Int
foreign Empty :: Tree


---- Native-language standard library

-- concat :: [a] -> [a] -> [a]
def concat xs ys =
    if null xs then
        return ys
    else
        return head xs : concat (tail xs) ys

def assert b :: Bool -> Unit =
    if not b then dieWithMessage "Assertion failed!"

def assertMessage b err :: Bool -> String -> Unit =
    if not b then dieWithMessage $ "Assertion failed: " ++ err

---- Set functions (see http://groups.csail.mit.edu/mac/users/adams/BB/92-10.ps)

def top tree =
    assertMessage (not $ null tree) "called top on empty set"

    let Node x l r c = tree
    return x

def left tree =
    assertMessage (not $ null tree) "called left on empty set"

    let Node x l r c = tree
    return l

def right tree =
    assertMessage (not $ null tree) "called right on empty set"

    let Node x l r c = tree
    return r

def count tree =
    if null tree then
        return 0
    else
        let Node x l r c = tree
        return c

def makeNode x l r :: Int -> Tree -> Tree -> Tree =
    myCount := (count l) + (count r)

    return Node x l r myCount

-- Rotations

def Set.singleL a x r :: Int -> Tree -> Tree -> Tree =
    b := top r
    y := left r
    z := right r

    return makeNode b (makeNode a x y) z

def Set.singleR b l z :: Int -> Tree -> Tree -> Tree =
    a := top l
    x := left l
    y := right l

    return makeNode a x (makeNode b y z)

def Set.doubleL a x r :: Int -> Tree -> Tree -> Tree =
    c := top r
    lr := left r
    b := top lr
    y1 := left lr
    y2 := right lr
    z := right r

    return makeNode b (makeNode a x y1) (makeNode c y2 z)

def Set.doubleR c l z :: Int -> Tree -> Tree -> Tree =
    a := top l
    x := left l
    rl := right l
    b := top rl
    y1 := left rl
    y2 := right rl

    return makeNode b (makeNode a x y1) (makeNode c y2 z)

-- Special constructor for self-balancing trees
def Set.balancedmakeNode v l r :: Int -> Tree -> Tree -> Tree =
    ln := count l
    rn := count r

    if ln + rn < 2 then
        return makeNode v l r
    else if rn > 4 * ln then
        rl := left r
        rr := right r
        rln := count rl
        rrn := count rr

        if rln < rrn then
            return Set.singleL v l r
        else
            return Set.doubleL v l r
    else if ln > 4 * rn then
        ll := left l
        lr := right l
        lln := count ll
        lrn := count lr

        if lrn < lln then
            return Set.singleR v l r
        else
            return Set.doubleR v l r
    else
        return makeNode v l r

-- Actual Set functions
def Set.empty :: Tree =
    return Empty

def Set.insert x set :: Int -> Tree -> Tree =
    if null set then
        return makeNode x Empty Empty

    current := top set
    if x == current then
        return set
    else if x < current then
        return Set.balancedmakeNode current (Set.insert x (left set)) (right set)
    else -- x > head
        return Set.balancedmakeNode current (left set) (Set.insert x (right set))

def Set.findMin set :: Tree -> Int =
    assertMessage (not $ null set) "Set.findMin: set is empty"

    if null $ left set then
        return top set
    else
        return Set.findMin $ left set

def Set.deleteMin set :: Tree -> Tree =
    assertMessage (not $ null set) "Set.deleteMin: set is empty"

    if null $ left set then
        return right set
    else
        return Set.balancedmakeNode (top set) (Set.deleteMin $ left set) (right set)

def Set.findMax set :: Tree -> Int =
    assertMessage (not $ null set) "Set.findMax: set is empty"

    if null $ right set then
        return top set
    else
        return Set.findMax $ right set

def Set.deleteMax set :: Tree -> Tree =
    assertMessage (not $ null set) "Set.deleteMax: set is empty"

    if null $ right set then
        return left set
    else
        return Set.balancedmakeNode (top set) (left set) (Set.deleteMax $ right set)

def Set.delete x set :: Int -> Tree -> Tree =
    if null set then
        return Empty

    value := top set
    if x < value then
        return Set.balancedmakeNode value (Set.delete x (left set)) (right set)
    else if x > value then
        return Set.balancedmakeNode value (left set) (Set.delete x (right set))
    else -- x == value
        if null $right set then
            return left set
        else if null $ left set then
            return right set
        else
            newHead := Set.findMin $ right set
            return Set.balancedmakeNode newHead (left set) (Set.deleteMin $ right set)

def Set.fromList xs :: [Int] -> Tree =
    result := Set.empty
    while not $ null xs do
        result = Set.insert (head xs) result
        xs = tail xs

    return result

def Set.toList set :: Tree -> [Int] =
    if null set then
        return []
    else
        return (Set.findMin set) : Set.toList $ Set.deleteMin set

-- Miscellanous functions
def range a b :: Int -> Int -> [Int] =
    xs := []

    i := b
    while i >= a do
        xs = i : xs
        i -= 1

    return xs

-- length :: [a] -> Int
def length xs =
    if null xs then
        return 0
    else
        return 1 + length $ tail xs

def sum xs :: [Int] -> Int =
    if null xs then
        return 0
    else
        return head xs + sum $ tail xs

def product xs :: [Int] -> Int =
    if null xs then
        return 1
    else
        return head xs * product $ tail xs

-- take :: Int -> [a] -> [a]
def take n xs =
    if n == 0 then
        return []
    else
        return head xs : take (n - 1) (tail xs)

-- drop :: Int -> [a] -> [a]
def drop n xs =
    if n == 0 then
        return xs
    else
        return drop (n - 1) (tail xs)

def max a b :: Int -> Int -> Int =
    if a > b then
        return a
    else
        return b

def maximum xs :: [Int] -> Int =
    if length xs == 1 then
        return head xs
    else
        return max (head xs) (maximum $ tail xs)

-- at :: Int -> [a] -> a
def at n xs =
    if n == 0 then
        return head xs
    else
        return at (n - 1) (tail xs)


-- reverse :: [a] -> [a]
def reverse xs =
    ys := []
    for x in xs do
        ys = x : ys

    return ys

def even x :: Int -> Bool =
    if x mod 2 == 0 then return True
    else return False

def odd x :: Int -> Bool =
    if x mod 2 == 0 then return False
    else return True

-- TODO: Make this work (allow functions as parameters)
--def filter f xs =
--    let ys = []
--    for x in xs do
--        if f x then ys = x : ys

--    return reverse ys

-- Non stack-destroying version
--def concat xs ys :: [Int] -> [Int] -> [Int] =
--    let zs :: [Int] = ys

--    for x in reverse xs do
--        zs = x : zs

--    return zs

def isSpace c :: Char -> Bool =
    if c == ' ' or c == '\n' or c == '\r' or c == '\t' then
        return True
    else
        return False

def trimLeft s :: String -> String =
    xs := []
    for c in s do
        if not $ isSpace c then xs = c : xs

    return reverse xs

def trim s :: String -> String =
    s1 := s
    while (not $ null s1) and (isSpace $ head s1) do
        s1 = tail s1

    s2 := reverse s1
    while (not $ null s2) and (isSpace $ head s2) do
        s2 = tail s2

    return reverse s2

def substring s start n :: String -> Int -> Int -> String =
    return take n (drop start s)

def split s :: String -> [String] =
    result := []
    start := 0
    for i in range 0 (length s - 1) do
        if isSpace $ at i s then
            if i != start then
                piece := substring s start (i - start)
                result = piece : result

            start = i + 1

    if start != length s then
        n := length s - start
        piece = substring s start n
        result = piece : result

    return reverse result

def join sep xs :: String -> [String] -> String =
    if null xs then
        return ""
    else if length xs == 1 then
        return head xs
    else
        return head xs ++ sep ++ join sep $ tail xs

def stringToInt s :: String -> Int =
    x := 0
    for digit in s do
        assertMessage (digit >= '0' and digit <= '9') "stringToInt: Digit out of range"

        x *= 10
        x += (digit - '0')

    return x

def show x :: Int -> String =
    if x == 0 then return "0"

    negative := (x < 0)
    if negative then x = 0 - x

    s := []
    while x != 0 do
        digit := x mod 10
        s = (digit + '0') : s
        x = x / 10

    if negative then s = '-' : s

    return s

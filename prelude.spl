def range a b :: Int -> Int -> List =
    let xs :: List = []

    let i :: Int = b
    while i >= a do
        xs = i : xs
        i -= 1

    return xs

def length xs :: List -> Int =
    if null xs then
        return 0
    else
        return 1 + length $ tail xs

def sum xs :: List -> Int =
    if null xs then
        return 0
    else
        return head xs + sum $ tail xs

def product xs :: List -> Int =
    if null xs then
        return 1
    else
        return head xs * product $ tail xs

def take n xs :: Int -> List -> List =
    if n == 0 then
        return []
    else
        return head xs : take (n - 1) (tail xs)

def max a b :: Int -> Int -> Int =
    if a > b then
        return a
    else
        return b

def maximum xs :: List -> Int =
    if length xs == 1 then
        return head xs
    else
        return max (head xs) (maximum $ tail xs)

def at n xs :: Int -> List -> Int =
    if n == 0 then
        return head xs
    else
        return at (n - 1) (tail xs)

def reverse xs :: List -> List =
    let ys :: List = []
    for x in xs do
        ys = x : ys

    return ys

def concat xs ys :: List -> List -> List =
    if null xs then
        return ys
    else
        return head xs : concat (tail xs) ys

def even x :: Int -> Bool =
    if x mod 2 == 0 then return True
    else return False

def odd x :: Int -> Bool =
    if x mod 2 == 0 then return False
    else return True

-- Non stack-destroying version
--def concat xs ys :: List -> List -> List =
--    let zs :: List = ys

--    for x in reverse xs do
--        zs = x : zs

--    return zs

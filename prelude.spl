---- Declarations for built-in functions written in C

foreign dieWithMessage :: String -> Unit

-- I/O functions
foreign read :: Int
foreign readLine :: String
foreign print :: Int -> Unit

-- List functions
-- foreign Cons :: Int -> [Int] -> [Int]

-- Tree functions
foreign Node :: Int -> Tree -> Tree -> Tree
foreign Empty :: Tree
foreign top :: Tree -> Int
foreign left :: Tree -> Tree
foreign right :: Tree -> Tree
foreign count :: Tree -> Int

-- String functions
foreign echo :: String -> Unit
foreign cat :: String -> String -> String
foreign len :: String -> Int
foreign charAt :: Int -> String -> Int
foreign listToString xs :: [Int] -> String


---- Native-language standard library

def assert b :: Bool -> Unit =
    if not b then dieWithMessage "Assertion failed!"

def assertMessage b err :: Bool -> String -> Unit =
    if not b then dieWithMessage $ cat "Assertion failed: " err

---- Set functions (see http://groups.csail.mit.edu/mac/users/adams/BB/92-10.ps)

-- Rotations
def Set.singleL a x r :: Int -> Tree -> Tree -> Tree =
    b :: Int := top r
    y :: Tree := left r
    z :: Tree := right r

    return Node b (Node a x y) z

def Set.singleR b l z :: Int -> Tree -> Tree -> Tree =
    a :: Int := top l
    x :: Tree := left l
    y :: Tree := right l

    return Node a x (Node b y z)

def Set.doubleL a x r :: Int -> Tree -> Tree -> Tree =
    c :: Int := top r
    lr :: Tree := left r
    b :: Int := top lr
    y1 :: Tree := left lr
    y2 :: Tree := right lr
    z :: Tree := right r

    return Node b (Node a x y1) (Node c y2 z)

def Set.doubleR c l z :: Int -> Tree -> Tree -> Tree =
    a :: Int := top l
    x :: Tree := left l
    rl :: Tree := right l
    b :: Int := top rl
    y1 :: Tree := left rl
    y2 :: Tree := right rl

    return Node b (Node a x y1) (Node c y2 z)

-- Special constructor for self-balancing trees
def Set.balancedNode v l r :: Int -> Tree -> Tree -> Tree =
    ln :: Int := count l
    rn :: Int := count r

    if ln + rn < 2 then
        return Node v l r
    else if rn > 4 * ln then
        rl :: Tree := left r
        rr :: Tree := right r
        rln :: Int := count rl
        rrn :: Int := count rr

        if rln < rrn then
            return Set.singleL v l r
        else
            return Set.doubleL v l r
    else if ln > 4 * rn then
        ll :: Tree := left l
        lr :: Tree := right l
        lln :: Int := count ll
        lrn :: Int := count lr

        if lrn < lln then
            return Set.singleR v l r
        else
            return Set.doubleR v l r
    else
        return Node v l r

-- Actual Set functions
def Set.empty :: Tree =
    return Empty

def Set.insert x set :: Int -> Tree -> Tree =
    if null set then
        return Node x Empty Empty

    current := top set
    if x == current then
        return set
    else if x < current then
        return Set.balancedNode current (Set.insert x (left set)) (right set)
    else -- x > head
        return Set.balancedNode current (left set) (Set.insert x (right set))

def Set.findMin set :: Tree -> Int =
    -- TODO: Check for empty set and die
    if null $ left set then
        return top set
    else
        return Set.findMin $ left set

def Set.deleteMin set :: Tree -> Tree =
    -- TODO: Check for empty set and die
    if null $ left set then
        return right set
    else
        return Set.balancedNode (top set) (Set.deleteMin $ left set) (right set)

def Set.findMax set :: Tree -> Int =
    -- TODO: Check for empty set and die
    if null $ right set then
        return top set
    else
        return Set.findMax $ right set

def Set.deleteMax set :: Tree -> Tree =
    -- TODO: Check for empty set and die
    if null $ right set then
        return left set
    else
        return Set.balancedNode (top set) (left set) (Set.deleteMax $ right set)

def Set.delete x set :: Int -> Tree -> Tree =
    if null set then
        return Empty

    value := top set
    if x < value then
        return Set.balancedNode value (Set.delete x (left set)) (right set)
    else if x > value then
        return Set.balancedNode value (left set) (Set.delete x (right set))
    else -- x == value
        if null $right set then
            return left set
        else if null $ left set then
            return right set
        else
            newHead := Set.findMin $ right set
            return Set.balancedNode newHead (left set) (Set.deleteMin $ right set)

def Set.fromList xs :: [Int] -> Tree =
    result := Set.empty
    while not $ null xs do
        result = Set.insert (head xs) result
        xs = tail xs

    return result

def Set.toList set :: Tree -> [Int] =
    if null set then
        return []
    else
        return (Set.findMin set) : Set.toList $ Set.deleteMin set

-- Miscellanous functions
def range a b :: Int -> Int -> [Int] =
    xs := []

    i := b
    while i >= a do
        xs = i : xs
        i -= 1

    return xs

-- length :: [a] -> Int
def length xs =
    if null xs then
        return 0
    else
        return 1 + length $ tail xs

def sum xs :: [Int] -> Int =
    if null xs then
        return 0
    else
        return head xs + sum $ tail xs

def product xs :: [Int] -> Int =
    if null xs then
        return 1
    else
        return head xs * product $ tail xs

-- take :: Int -> [a] -> [a]
def take n xs =
    if n == 0 then
        return []
    else
        return head xs : take (n - 1) (tail xs)

-- drop :: Int -> [a] -> [a]
def drop n xs =
    if n == 0 then
        return xs
    else
        return drop (n - 1) (tail xs)

def max a b :: Int -> Int -> Int =
    if a > b then
        return a
    else
        return b

def maximum xs :: [Int] -> Int =
    if length xs == 1 then
        return head xs
    else
        return max (head xs) (maximum $ tail xs)

-- at :: Int -> [a] -> a
def at n xs =
    if n == 0 then
        return head xs
    else
        return at (n - 1) (tail xs)


-- reverse :: [a] -> [a]
def reverse xs =
    ys := []
    for x in xs do
        ys = x : ys

    return ys

-- concat :: [a] -> [a] -> [a]
def concat xs ys =
    if null xs then
        return ys
    else
        return head xs : concat (tail xs) ys

def even x :: Int -> Bool =
    if x mod 2 == 0 then return True
    else return False

def odd x :: Int -> Bool =
    if x mod 2 == 0 then return False
    else return True

-- TODO: Make this work (allow functions as parameters)
--def filter f xs =
--    let ys = []
--    for x in xs do
--        if f x then ys = x : ys

--    return reverse ys

-- Non stack-destroying version
--def concat xs ys :: [Int] -> [Int] -> [Int] =
--    let zs :: [Int] = ys

--    for x in reverse xs do
--        zs = x : zs

--    return zs

def stringToList s :: String -> [Int] =
    xs := []
    for i in range 0 (len s - 1) do
        xs = (charAt i s) : xs

    return reverse xs

def isSpace c :: Int -> Bool =
    if c == ' ' or c == '\n' or c == '\r' or c == '\t' then
        return True
    else
        return False

def trimLeft s :: String -> String =
    s' := stringToList s

    xs := []
    for c in s' do
        if not $ isSpace c then xs = c : xs

    return listToString $ reverse $ xs

def trim s :: String -> String =
    s1 := stringToList s

    while (not $ null s1) and (isSpace $ head s1) do
        s1 = tail s1

    s2 := reverse s1
    while (not $ null s2) and (isSpace $ head s2) do
        s2 = tail s2

    return listToString $ reverse s2

def substring s start n :: String -> Int -> Int -> String =
    s1 := stringToList s
    s2 := drop start s1
    s3 := take n s2

    return listToString s3

def split s :: String -> [String] =
    result := []
    start := 0
    for i in range 0 (len s - 1) do
        if isSpace $ charAt i s then
            if i != start then
                piece := substring s start (i - start)
                result = piece : result

            start = i + 1

    if start != len s then
        n := len s - start
        piece = substring s start n
        result = piece : result

    return reverse result

def join sep xs :: String -> [String] -> String =
    if null xs then
        return ""
    else if length xs == 1 then
        return head xs
    else
        return cat (head xs) (cat sep (join sep (tail xs)))

def stringToInt s :: String -> Int =
    digits := stringToList s

    x := 0
    for digit in digits do
        assertMessage (digit >= '0' and digit <= '9') "stringToInt: Digit out of range"

        x *= 10
        x += (digit - '0')

    return x

def intToString x :: Int -> String =
    if x == 0 then return "0"

    negative := (x < 0)
    if negative then x = 0 - x

    s := []
    while x != 0 do
        digit := x mod 10
        s = (digit + '0') : s
        x = x / 10

    if negative then s = '-' : s

    return listToString s






---- Declarations for built-in functions written in C

foreign dieWithMessage :: String -> Unit

-- I/O functions
foreign read :: Int
foreign readLine :: String
foreign print :: Int -> Unit

-- List functions
-- foreign Cons :: Int -> [Int] -> [Int]

-- Tree functions
foreign Node :: Int -> Tree -> Tree -> Tree
foreign Empty :: Tree
foreign top :: Tree -> Int
foreign left :: Tree -> Tree
foreign right :: Tree -> Tree
foreign count :: Tree -> Int

-- String functions
foreign echo :: String -> Unit
foreign cat :: String -> String -> String
foreign len :: String -> Int
foreign charAt :: Int -> String -> Int
foreign listToString xs :: [Int] -> String


---- Native-language standard library

def assert b :: Bool -> Unit =
    if not b then dieWithMessage "Assertion failed!"

def assertMessage b err :: Bool -> String -> Unit =
    if not b then dieWithMessage $ cat "Assertion failed: " err

---- Set functions (see http://groups.csail.mit.edu/mac/users/adams/BB/92-10.ps)

-- Rotations
def Set.singleL a x r :: Int -> Tree -> Tree -> Tree =
    let b :: Int = top r
    let y :: Tree = left r
    let z :: Tree = right r

    return Node b (Node a x y) z

def Set.singleR b l z :: Int -> Tree -> Tree -> Tree =
    let a :: Int = top l
    let x :: Tree = left l
    let y :: Tree = right l

    return Node a x (Node b y z)

def Set.doubleL a x r :: Int -> Tree -> Tree -> Tree =
    let c :: Int = top r
    let lr :: Tree = left r
    let b :: Int = top lr
    let y1 :: Tree = left lr
    let y2 :: Tree = right lr
    let z :: Tree = right r

    return Node b (Node a x y1) (Node c y2 z)

def Set.doubleR c l z :: Int -> Tree -> Tree -> Tree =
    let a :: Int = top l
    let x :: Tree = left l
    let rl :: Tree = right l
    let b :: Int = top rl
    let y1 :: Tree = left rl
    let y2 :: Tree = right rl

    return Node b (Node a x y1) (Node c y2 z)

-- Special constructor for self-balancing trees
def Set.balancedNode v l r :: Int -> Tree -> Tree -> Tree =
    let ln :: Int = count l
    let rn :: Int = count r

    if ln + rn < 2 then
        return Node v l r
    else if rn > 4 * ln then
        let rl :: Tree = left r
        let rr :: Tree = right r
        let rln :: Int = count rl
        let rrn :: Int = count rr

        if rln < rrn then
            return Set.singleL v l r
        else
            return Set.doubleL v l r
    else if ln > 4 * rn then
        let ll :: Tree = left l
        let lr :: Tree = right l
        let lln :: Int = count ll
        let lrn :: Int = count lr

        if lrn < lln then
            return Set.singleR v l r
        else
            return Set.doubleR v l r
    else
        return Node v l r

-- Actual Set functions
def Set.empty :: Tree =
    return Empty

def Set.insert x set :: Int -> Tree -> Tree =
    if null set then
        return Node x Empty Empty

    let current :: Int = top set
    if x == current then
        return set
    else if x < current then
        return Set.balancedNode current (Set.insert x (left set)) (right set)
    else -- x > head
        return Set.balancedNode current (left set) (Set.insert x (right set))

def Set.findMin set :: Tree -> Int =
    -- TODO: Check for empty set and die
    if null $ left set then
        return top set
    else
        return Set.findMin $ left set

def Set.deleteMin set :: Tree -> Tree =
    -- TODO: Check for empty set and die
    if null $ left set then
        return right set
    else
        return Set.balancedNode (top set) (Set.deleteMin $ left set) (right set)

def Set.findMax set :: Tree -> Int =
    -- TODO: Check for empty set and die
    if null $ right set then
        return top set
    else
        return Set.findMax $ right set

def Set.deleteMax set :: Tree -> Tree =
    -- TODO: Check for empty set and die
    if null $ right set then
        return left set
    else
        return Set.balancedNode (top set) (left set) (Set.deleteMax $ right set)

def Set.delete x set :: Int -> Tree -> Tree =
    if null set then
        return Empty

    let value :: Int = top set
    if x < value then
        return Set.balancedNode value (Set.delete x (left set)) (right set)
    else if x > value then
        return Set.balancedNode value (left set) (Set.delete x (right set))
    else -- x == value
        if null $right set then
            return left set
        else if null $ left set then
            return right set
        else
            let newHead :: Int = Set.findMin $ right set
            return Set.balancedNode newHead (left set) (Set.deleteMin $ right set)

def Set.fromList xs :: [Int] -> Tree =
    let result :: Tree = Set.empty
    while not $ null xs do
        result = Set.insert (head xs) result
        xs = tail xs

    return result

def Set.toList set :: Tree -> [Int] =
    if null set then
        return []
    else
        return (Set.findMin set) : Set.toList $ Set.deleteMin set

-- Miscellanous functions
def range a b :: Int -> Int -> [Int] =
    let xs :: [Int] = []

    let i :: Int = b
    while i >= a do
        xs = i : xs
        i -= 1

    return xs

-- length :: [a] -> Int
def length xs =
    if null xs then
        return 0
    else
        return 1 + length $ tail xs

def sum xs :: [Int] -> Int =
    if null xs then
        return 0
    else
        return head xs + sum $ tail xs

def product xs :: [Int] -> Int =
    if null xs then
        return 1
    else
        return head xs * product $ tail xs

-- take :: Int -> [a] -> [a]
def take n xs =
    if n == 0 then
        return []
    else
        return head xs : take (n - 1) (tail xs)

-- drop :: Int -> [a] -> [a]
def drop n xs =
    if n == 0 then
        return xs
    else
        return drop (n - 1) (tail xs)

def max a b :: Int -> Int -> Int =
    if a > b then
        return a
    else
        return b

def maximum xs :: [Int] -> Int =
    if length xs == 1 then
        return head xs
    else
        return max (head xs) (maximum $ tail xs)

-- at :: Int -> [a] -> a
def at n xs =
    if n == 0 then
        return head xs
    else
        return at (n - 1) (tail xs)


-- reverse :: [a] -> [a]
def reverse xs =
    let ys = []
    for x in xs do
        ys = x : ys

    return ys

-- concat :: [a] -> [a] -> [a]
def concat xs ys =
    if null xs then
        return ys
    else
        return head xs : concat (tail xs) ys

def even x :: Int -> Bool =
    if x mod 2 == 0 then return True
    else return False

def odd x :: Int -> Bool =
    if x mod 2 == 0 then return False
    else return True

-- TODO: Make this work (allow functions as parameters)
--def filter f xs =
--    let ys = []
--    for x in xs do
--        if f x then ys = x : ys

--    return reverse ys

-- Non stack-destroying version
--def concat xs ys :: [Int] -> [Int] -> [Int] =
--    let zs :: [Int] = ys

--    for x in reverse xs do
--        zs = x : zs

--    return zs

def stringToList s :: String -> [Int] =
    let xs = []
    for i in range 0 (len s - 1) do
        xs = (charAt i s) : xs

    return reverse xs

def isSpace c :: Int -> Bool =
    if c == ' ' or c == '\n' or c == '\r' or c == '\t' then
        return True
    else
        return False

def trimLeft s :: String -> String =
    let s' = stringToList s

    let xs = []
    for c in s' do
        if not $ isSpace c then xs = c : xs

    return listToString $ reverse $ xs

def trim s :: String -> String =
    let s1 = stringToList s

    while (not $ null s1) and (isSpace $ head s1) do
        s1 = tail s1

    let s2 = reverse s1
    while (not $ null s2) and (isSpace $ head s2) do
        s2 = tail s2

    return listToString $ reverse s2

def substring s start n :: String -> Int -> Int -> String =
    let s1 = stringToList s
    let s2 = drop start s1
    let s3 = take n s2

    return listToString s3

def split s :: String -> [String] =
    let result = []
    let start = 0
    for i in range 0 (len s - 1) do
        if isSpace $ charAt i s then
            if i != start then
                let piece = substring s start (i - start)
                result = piece : result

            start = i + 1

    if start != len s then
        let n = len s - start
        let piece' = substring s start n
        result = piece' : result

    return reverse result

def stringToInt s :: String -> Int =
    let digits = stringToList s

    let x = 0
    for digit in digits do
        assertMessage (digit >= '0' and digit <= '9') "stringToInt: Digit out of range"

        x *= 10
        x += (digit - '0')

    return x

def intToString x :: Int -> String =
    if x == 0 then return "0"

    let negative = (x < 0)
    if negative then x = 0 - x

    let s = []
    while x != 0 do
        let digit = x mod 10
        s = (digit + '0') : s
        x = x / 10

    if negative then s = '-' : s

    return listToString s






# Equality
def eqInt(x: Int, y: Int) -> Bool
    return (x == y)


def eqList(xs: [Int], ys: [Int]) -> Bool
    if null xs: return null ys
    if null ys: return null xs

    return (head xs == head ys) and (eqList (tail xs) (tail ys))


# Comparisons
## x < y   =>  -1
## x > y   =>  +1
## x == y  =>   0
def cmpInt(x: Int, y: Int) -> Int
    return (x - y)


def cmpList(xs: [Int], ys: [Int]) -> Int
    if null xs
        if null ys
            return 0
        else
            return -1
    elif null ys
        return 1
    else
        if (head xs) < (head ys)
            return -1
        elif (head xs) > (head ys)
            return 1
        else
            return cmpList (tail xs) (tail ys)


def cmpString(xs: String, ys: String) -> Int
    n1 := strLength xs
    n2 := strLength ys

    for n = 0 to min n1 n2
        if strLength xs <= n
            if strLength ys <= n
                return 0
            else
                return -1
        elif strLength ys <= n
            return 1
        else
            if strAt xs n < strAt ys n
                return -1
            elif strAt xs n > strAt ys n
                return 1

    die "Unreachable"


# List operations
def isIn<T>(eq: |T, T| -> Bool, x: T, ys: [T]) -> Bool
    for y in ys
        if eq x y: return True

    return False


def splitList<T>(cmp: |T, T| -> Int, xs: [T], pivot: T) -> Pair [T]
    lhs := []
    rhs := []

    for x in xs
        if cmp x pivot < 0
            lhs = x :: lhs
        else
            rhs = x :: rhs

    return Pair lhs rhs


def sort<T>(cmp: |T, T| -> Int, xs: [T]) -> [T]
    if length xs <= 1
        return xs

    pivot := head xs
    let Pair lhs rhs := splitList cmp (tail xs) pivot

    return (sort cmp lhs) ++ [pivot] ++ (sort cmp rhs)


def uniquify<T>(cmp: |T, T| -> Int, xs: [T]) -> [T]
    if null xs: return []

    xs = sort cmp xs

    result := [head xs]
    last := head xs

    for x in tail xs
        if cmp last x != 0
            result = x :: result

        last = x

    return result

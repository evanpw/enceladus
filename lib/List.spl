# Equality
def eqInt(x: Int, y: Int) -> Bool
    return (x == y)


def eqList(xs: [Int], ys: [Int]) -> Bool
    if null xs: return null ys
    if null ys: return null xs

    return (head xs == head ys) and (eqList (tail xs) (tail ys))


# Comparisons
## x < y   =>  -1
## x > y   =>  +1
## x == y  =>   0
def cmpInt(x: Int, y: Int) -> Int
    return (x - y)


def cmpList(xs: [Int], ys: [Int]) -> Int
    if null xs
        if null ys
            return 0
        else
            return -1
    elif null ys
        return 1
    else
        if (head xs) < (head ys)
            return -1
        elif (head xs) > (head ys)
            return 1
        else
            return cmpList (tail xs) (tail ys)


def cmpString(xs: String, ys: String) -> Int
    n1 := strLength xs
    n2 := strLength ys

    for n in range 0 (min n1 n2)
        if strLength xs <= n
            if strLength ys <= n
                return 0
            else
                return -1
        elif strLength ys <= n
            return 1
        else
            if strAt xs n < strAt ys n
                return -1
            elif strAt xs n > strAt ys n
                return 1

    die "Unreachable"


# List operations
def isIn(eq: |a, a| -> Bool, x: a, ys: [a]) -> Bool
    for y in ys
        if eq x y: return True

    return False


def splitList(cmp: |a, a| -> Int, xs: [a], pivot: a) -> Pair [a]
    lhs := []
    rhs := []

    for x in xs
        if cmp x pivot < 0
            lhs = x :: lhs
        else
            rhs = x :: rhs

    return Pair lhs rhs


def sort(cmp: |a, a| -> Int, xs: [a]) -> [a]
    if length xs <= 1
        return xs

    pivot := head xs
    let Pair lhs rhs = splitList cmp (tail xs) pivot

    return (sort cmp lhs) ++ [pivot] ++ (sort cmp rhs)


def uniquify(cmp: |a, a| -> Int, xs: [a]) -> [a]
    if null xs: return []

    xs = sort cmp xs

    result := [head xs]
    last := head xs

    for x in tail xs
        if cmp last x != 0
            result = x :: result

        last = x

    return result

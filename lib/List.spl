# List operations
def isIn<T: Eq>(x: T, ys: [T]) -> Bool
    for y in ys
        if x == y
            return True

    return False


def splitList<T: PartialOrd>(xs: [T], pivot: T) -> Pair<[T], [T]>
    lhs := []
    rhs := []

    for x in xs
        if x < pivot
            lhs = lhs.insert(x)
        else
            rhs = rhs.insert(x)

    return Pair(lhs, rhs)


def sort<T: PartialOrd>(xs: [T]) -> [T]
    if xs.length() <= 1
        return xs

    pivot := xs.head()
    let Pair(lhs, rhs) := splitList(xs.tail(), pivot)

    return sort(lhs) ++ [pivot] ++ sort(rhs)


# Needs sub-traits to work correctly, so that Ord => PartialOrd and we can
# call sort
#def uniquify<T: Ord>(xs: [T]) -> [T]
#    if xs.empty()
#        return []

#    xs = sort(xs)

#    result := [xs.head()]
#    last := xs.head()

#    for x in xs.tail()
#        match last.cmp(x)
#            Equal
#                pass
#            Less
#                result = result.insert(x)
#            Greater
#                result = result.insert(x)

#        last = x

#    return result

def uniquify<T: PartialOrd + Eq>(xs: [T]) -> [T]
    if xs.empty()
        return []

    xs = sort(xs)

    result := [xs.head()]
    last := xs.head()

    for x in xs.tail()
        if x != last
            result = result.insert(x)

        last = x

    return result

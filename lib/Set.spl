# Tree functions
data Tree = Node Int Tree Tree Int | Empty

## Set functions (see http://groups.csail.mit.edu/mac/users/adams/BB/92-10.ps)

def isEmpty(tree: Tree) -> Bool
    match tree
        Node _ _ _ _ => return False
        Empty => return True


def top(tree: Tree) -> Int
    match tree
        Node x _ _ _ => return x
        Empty => panic "Called top on empty set"


def left(tree: Tree) -> Tree
    match tree
        Node _ l _ _ => return l
        Empty => panic "Called left on empty set"


def right(tree: Tree) -> Tree
    match tree
        Node _ _ r _ => return r
        Empty => panic "Called right on empty set"


def count(tree: Tree) -> Int
    match tree
        Node _ _ _ c => return c
        Empty => return 0


def makeNode(x: Int, l: Tree, r: Tree) -> Tree
    myCount := (count l) + (count r)

    return Node x l r myCount


# Rotations

def Set.singleL(a: Int, x: Tree, r: Tree) -> Tree
    match r
        Node b y z _ => return makeNode b (makeNode a x y) z
        Empty => panic "Set.singleL: r is Empty"


def Set.singleR(b: Int, l: Tree, z: Tree) -> Tree
    match l
        Node a x y _ => return makeNode a x (makeNode b y z)
        Empty => panic "singleR: l is Empty"


def Set.doubleL(a: Int, x: Tree, r: Tree) -> Tree
    match r
        Node c lr _ _ => match lr
            Node b y1 y2 _ =>
                z := right r
                return makeNode b (makeNode a x y1) (makeNode c y2 z)
            Empty => panic "doubleL: lr is Empty"
        Empty => panic "doubleL: r is Empty"


def Set.doubleR(c: Int, l: Tree, z: Tree) -> Tree
    match l
        Node a x rl _ => match rl
            Node b y1 y2 _ => return makeNode b (makeNode a x y1) (makeNode c y2 z)
            Empty => panic "doubleR: rl is Empty"
        Empty => panic "l is Empty"


# Special constructor for self-balancing trees
def Set.balancedNode(v: Int, l: Tree, r: Tree) -> Tree
    ln := count l
    rn := count r

    if ln + rn < 2
        return makeNode v l r

    elif rn > 4 * ln
        match r
            Node _ rl rr _ =>
                rln := count rl
                rrn := count rr

                if rln < rrn
                    return Set.singleL v l r
                else
                    return Set.doubleL v l r
            Empty => panic "Set.balancedNode: r is Empty"

    elif ln > 4 * rn
        match l
            Node _ ll lr _ =>
                lln := count ll
                lrn := count lr

                if lrn < lln
                    return Set.singleR v l r
                else
                    return Set.doubleR v l r
            Empty => panic "Set.balancedNode: l is Empty"

    else
        return makeNode v l r


# Actual Set functions
def Set.empty() -> Tree
    return Empty


def Set.insert(x: Int, set: Tree) -> Tree
    if isEmpty set
        return makeNode x Empty Empty

    current := top set
    if x == current
        return set
    elif x < current
        return Set.balancedNode current (Set.insert x (left set)) (right set)
    else # x > head
        return Set.balancedNode current (left set) (Set.insert x (right set))


def Set.findMin(set: Tree) -> Int
    assertMessage (not $ isEmpty set) "Set.findMin: set is empty"

    match left set
        Node _ _ _ _ => return Set.findMin $ left set
        Empty => return top set


def Set.deleteMin(set: Tree) -> Tree
    assertMessage (not $ isEmpty set) "Set.deleteMin: set is empty"

    match left set
        Node _ _ _ _ => return Set.balancedNode (top set) (Set.deleteMin $ left set) (right set)
        Empty => return right set


def Set.findMax(set: Tree) -> Int
    assertMessage (not $ isEmpty set) "Set.findMax: set is empty"

    match right set
        Node _ _ _ _ => return Set.findMax $ right set
        Empty => return top set


def Set.deleteMax(set: Tree) -> Tree
    assertMessage (not $ isEmpty set) "Set.deleteMax: set is empty"

    match right set
        Node _ _ _ _ => return Set.balancedNode (top set) (left set) (Set.deleteMax $ right set)
        Empty => return left set


def Set.delete(x: Int, set: Tree) -> Tree
    if isEmpty set
        return Empty

    value := top set
    if x < value
        return Set.balancedNode value (Set.delete x (left set)) (right set)

    elif x > value
        return Set.balancedNode value (left set) (Set.delete x (right set))

    else # x == value
        if isEmpty $ right set
            return left set
        elif isEmpty $ left set
            return right set
        else
            newHead := Set.findMin $ right set
            return Set.balancedNode newHead (left set) (Set.deleteMin $ right set)


def Set.fromList(xs: [Int]) -> Tree
    result := Set.empty
    while not $ null xs
        result = Set.insert (head xs) result
        xs = tail xs

    return result


def Set.toList(set: Tree) -> [Int]
    match set
        Empty => return []
        Node _ _ _ _ => (Set.findMin set) :: Set.toList $ Set.deleteMin set

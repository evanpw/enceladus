## Declarations for built-in functions written in C

# String functions
type Char = Int
type String = [Char]

# I/O functions
foreign read () -> Int
foreign readLine () -> String
foreign print (msg: String) -> Unit
foreign dieWithMessage (msg: String) -> a


## Native-language standard library

def concat(xs: [a], ys: [a]) -> [a]
    if null xs
        return ys
    else
        return head xs :: concat (tail xs) ys


def assert(b: Bool) -> Unit
    if not b: dieWithMessage "Assertion failed!"


def assertMessage(b: Bool, err: String) -> Unit
    if not b: dieWithMessage $ "Assertion failed: " ++ err


# Miscellanous functions
def range(a: Int, b: Int) -> [Int]
    xs := []

    i := b
    while i >= a
        xs = i :: xs
        i -= 1

    return xs


def length(xs: [a]) -> Int
    result := 0

    while not $ null xs
        xs = tail xs
        result += 1

    return result


def sum(xs: [Int]) -> Int
    if null xs
        return 0
    else
        return head xs + sum $ tail xs


def product(xs: [Int]) -> Int
    if null xs
        return 1
    else
        return head xs * product $ tail xs


def take(n: Int, xs: [a]) -> [a]
    if n == 0
        return []
    else
        return head xs :: take (n - 1) (tail xs)


def drop(n: Int, xs: [a]) -> [a]
    if n == 0
        return xs
    else
        return drop (n - 1) (tail xs)


def max(a: Int, b: Int) -> Int
    if a > b
        return a
    else
        return b


def maximum(xs: [Int]) -> Int
    if length xs == 1
        return head xs
    else
        return max (head xs) (maximum $ tail xs)


def at(n: Int, xs: [a]) -> a
    while n > 0
        xs = tail xs
        n -= 1

    return head xs


def reverse(xs: [a]) -> [a]
    ys := []
    for x in xs
        ys = x :: ys

    return ys


def map(f: a -> b, xs: [a]) -> [b]
    result := []
    for x in xs
        result = f x :: result

    return reverse result


def filter(f: a -> Bool, xs: [a]) -> [a]
    ys := []
    for x in xs
        if f x: ys = x :: ys

    return reverse ys


def even(x: Int) -> Bool
    if x mod 2 == 0: return True
    else: return False


def odd(x: Int) -> Bool
    if x mod 2 == 0: return False
    else: return True


def pow(a: Int, b: Int) -> Int
    r := 1
    while True
        if b mod 2 == 1: r *= a
        b /= 2
        if b == 0: break
        a *= a

    return r


# Non stack-destroying version
#def concat xs ys :: [Int] -> [Int] -> [Int]
#    let zs :: [Int] = ys

#    for x in reverse xs
#        zs = x :: zs

#    return zs


## Strings ##

def show(x: Int) -> String
    if x == 0: return "0"

    negative := (x < 0)
    if negative: x = 0 - x

    s := []
    while x != 0
        digit := x mod 10
        s = (digit + '0') :: s
        x = x / 10

    if negative: s = '-' :: s

    return s


## Pairs ##

data Pair a = Pair a a


def fst(pair: Pair a) -> a
    let Pair x _ = pair
    return x


def snd(pair: Pair a) -> a
    let Pair _ x = pair
    return x


def splitAt(n: Int, xs: [a]) -> Pair [a]
    return Pair (take n xs) (drop n xs)

data List<T> = Cons(T, List<T>) | Nil

## String ##
type Char = Int
foreign strLength(s: String) -> Int
foreign strSlice(s: String, pos: Int, len: Int) -> String
foreign strAt(s: String, n: Int) -> Char
foreign strFromList(s: [Char]) -> String
foreign strCat(lhs: String, rhs: String) -> String
foreign show(x: Int) -> String

# Method wrappers (methods can't be implemented in C)
impl String
    def length(self: String) -> Int
        return strLength(self)

    def slice(self: String, pos: Int, len: Int) -> String
        return strSlice(self, pos, len)

    def at(self: String, n: Int) -> Int
        return strAt(self, n)

    def concat(self: String, other: String) -> String
        return strCat(self, other)

## Array ##
foreign emptyArray<T>() -> Array<T>
foreign makeArray<T>(n: Int, value: T) -> Array<T>
foreign arrayAt<T>(arr: Array<T>, n: Int) -> T
foreign arraySet<T>(arr: Array<T>, n: Int, value: T) -> Unit

# Method wrappers (methods can't be implemented in C)
impl<T> Array<T>
    def at(self: Array<T>, n: Int) -> T
        return arrayAt(self, n)

    def set(self: Array<T>, n: Int, value: T) -> Unit
        arraySet(self, n, value)


foreign die<T>(msg: String) -> T

## Option ##
data Option<T> = Some(T) | None

impl<T> Option<T>
    def isSome(self: Option<T>) -> Bool
        match self
            Some(_)
                return True
            None
                return False

    def isNone(self: Option<T>) -> Bool
        match self
            Some(_)
                return False
            None
                return True

    def unwrap(self: Option<T>) -> T
        match self
            Some(y)
                return y
            None
                die("*** Exception: Cannot unwrap None")

    def unwrapOr(self: Option<T>, other: T) -> T
        match self
            Some(y)
                return y
            None
                return other

# I/O functions
foreign read() -> Int
foreign readLine() -> Option<String>
foreign print(msg: String) -> Unit

## List ##
impl<T> List<T>
    def head(self: [T]) -> T
        match self
            Cons(x, _)
                return x
            Nil
                die("*** Exception: Called head on empty list")

    def tail(self: [T]) -> [T]
        match self
            Cons(_, rest)
                return rest
            Nil
                die("*** Exception: Called tail on empty list")

    def empty(self: [T]) -> Bool
        match self
            Cons(_, _)
                return False
            Nil
                return True

    def length(self: [T]) -> Int
        result := 0
        xs := self

        while not xs.empty()
            xs = xs.tail()
            result += 1

        return result

    def take(self: [T], n: Int) -> [T]
        if n == 0
            return []
        else
            return self.head() :: self.tail().take(n - 1)

    def drop(self: [T], n: Int) -> [T]
        if n == 0
            return self
        else
            return self.tail().drop(n - 1)

    def at(self: [T], n: Int) -> T
        xs := self

        while n > 0
            xs = xs.tail()
            n -= 1

        return xs.head()

    def reverse(self: [T]) -> [T]
        ys := []
        for x in self
            ys = x :: ys

        return ys

    def concat(self: [T], other: [T]) -> [T]
        result := other

        for x in self.reverse()
            result = x :: result

        return result

    def filter(self: [T], f: T -> Bool) -> [T]
        result := []
        for x in self
            if f(x)
                result = x :: result

        return result.reverse()

    def map<S>(self: [T], f: T -> S) -> [S]
        result := []
        for x in self
            result = f(x) :: result

        return result.reverse()


## Range ##
struct Range
    start: Int
    end: Int

def range(start: Int, end: Int) -> Range
    return Range(start, end)

impl Range
    def head(self: Range) -> Int
        assert self.start <= self.end
        return self.start

    def tail(self: Range) -> Range
        assert self.start <= self.end
        return Range(self.start + 1, self.end)

    def empty(self: Range) -> Bool
        return self.start > self.end

    def toList(self: Range) -> [Int]
        result := []

        i := self.end
        while i >= self.start
            result = i :: result
            i -= 1

        return result


## Native-language standard library
def assertMessage(b: Bool, err: String) -> Unit
    if not b
        die("*** Exception: Assertion failed: " ++ err)


def sum(xs: [Int]) -> Int
    result := 0
    for x in xs
        result += x

    return result


def product(xs: [Int]) -> Int
    if xs.empty()
        return 1
    else
        return xs.head() * product(xs.tail())


def max(a: Int, b: Int) -> Int
    if a > b
        return a
    else
        return b


def min(a: Int, b: Int) -> Int
    if a < b
        return a
    else
        return b


def maximum(xs: [Int]) -> Int
    if xs.length() == 1
        return xs.head()
    else
        return max(xs.head(), maximum(xs.tail()))


def minimum(xs: [Int]) -> Int
    if xs.length() == 1
        return xs.head()
    else
        return min(xs.head(), minimum(xs.tail()))


def even(x: Int) -> Bool
    if x mod 2 == 0
        return True
    else
        return False


def odd(x: Int) -> Bool
    if x mod 2 == 0
        return False
    else
        return True


def pow(a: Int, b: Int) -> Int
    r := 1
    forever
        if b mod 2 == 1
            r *= a

        b /= 2

        if b == 0
            break

        a *= a

    return r

# Modulo operator with b > 0 that satisfies 0 <= imod(a, b) < b even if a < 0
def imod(a: Int, b: Int) -> Int
    assert b > 0

    result := a mod b
    if result < 0
        result += b

    return result


## Pair ##
data Pair<S, T> = Pair(S, T)

impl<S, T> Pair<S, T>
    def first(self: Pair<S, T>) -> S
        match self
            Pair(x, _) => return x

    def second(self: Pair<S, T>) -> T
        match self
            Pair(_, x) => return x


def splitAt<T>(n: Int, xs: [T]) -> Pair<[T], [T]>
    return Pair(xs.take(n), xs.drop(n))

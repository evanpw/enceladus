foreign panic<T>(msg: String) -> T

## List ##
data List<T> = Cons(T, List<T>) | Nil

## String ##
type Char = Int
foreign strLength(s: String) -> UInt
foreign strSlice(s: String, pos: UInt, len: UInt) -> String
foreign strAt(s: String, n: UInt) -> Char
foreign strFromList(s: [Char]) -> String
foreign strCat(lhs: String, rhs: String) -> String
foreign strHash(s: String) -> UInt
foreign show(x: Int) -> String
foreign showUInt(x: UInt) -> String

struct StringIterator
    str: String
    offset: UInt

# Method wrappers (methods can't be implemented in C)
impl String
    def length(self: String) -> UInt
        return strLength(self)

    def slice(self: String, pos: UInt, len: UInt) -> String
        return strSlice(self, pos, len)

    def at(self: String, n: UInt) -> Int
        return strAt(self, n)

    def concat(self: String, other: String) -> String
        return strCat(self, other)

    def iter(self: String) -> StringIterator
        return StringIterator(self, 0u)

impl StringIterator
    def head(self: StringIterator) -> Char
        return self.str[self.offset]

    def tail(self: StringIterator) -> StringIterator
        assert self.offset < self.str.length()
        return StringIterator(self.str, self.offset + 1u)

    def empty(self: StringIterator) -> Bool
        return self.offset >= self.str.length()

## Array ##
# FOR INTERNAL USE ONLY: Does not initialize the array
foreign unsafeMakeArray<T>(size: UInt) -> Array<T>
foreign unsafeArrayAt<T>(arr: Array<T>, n: UInt) -> T
foreign unsafeArraySet<T>(arr: Array<T>, n: UInt, value: T) -> Unit
foreign arrayLength<T>(arr: Array<T>) -> UInt

def emptyArray<T>() -> Array<T>
    return unsafeMakeArray(0)

def makeArray<T>(size: UInt, value: T) -> Array<T>
    arr := unsafeMakeArray(size)

    # MUST NOT collect garbage in between allocation and initialization
    # if T is boxed

    i := 0
    while i < size
        unsafeArraySet(arr, i, value)
        i += 1

    return arr

# Method wrappers (methods can't be implemented in C)
impl<T> Array<T>
    def at(self: Array<T>, n: UInt) -> T
        assert n < arrayLength(self)
        return unsafeArrayAt(self, n)

    def set(self: Array<T>, n: UInt, value: T) -> Unit
        assert n < arrayLength(self)
        unsafeArraySet(self, n, value)

    def length(self: Array<T>) -> UInt
        return arrayLength(self)


## Option ##
data Option<T> = Some(T) | None

impl<T> Option<T>
    def isSome(self: Option<T>) -> Bool
        match self
            Some(_)
                return True
            None
                return False

    def isNone(self: Option<T>) -> Bool
        match self
            Some(_)
                return False
            None
                return True

    def unwrap(self: Option<T>) -> T
        match self
            Some(y)
                return y
            None
                panic $ "Cannot unwrap None"

    def unwrapOr(self: Option<T>, other: T) -> T
        match self
            Some(y)
                return y
            None
                return other

## I/O functions
foreign read() -> Int
foreign readLine() -> Option<String>
foreign print(msg: String) -> Unit

# HACK: Make sure these constructors exist for the C library to use
neverUsed := Some("Hello")
neverUsed = None

## List ##
impl<T> List<T>
    def head(self: [T]) -> T
        match self
            Cons(x, _)
                return x
            Nil
                panic $ "Called head on empty list"

    def tail(self: [T]) -> [T]
        match self
            Cons(_, rest)
                return rest
            Nil
                panic $ "Called tail on empty list"

    def empty(self: [T]) -> Bool
        match self
            Cons(_, _)
                return False
            Nil
                return True

    def length(self: [T]) -> UInt
        result := 0
        xs := self

        while not xs.empty()
            xs = xs.tail()
            result += 1

        return result

    def take(self: [T], n: UInt) -> [T]
        if n == 0
            return []
        else
            return self.head() :: self.tail().take(n - 1)

    def drop(self: [T], n: UInt) -> [T]
        if n == 0
            return self
        else
            return self.tail().drop(n - 1)

    def at(self: [T], n: UInt) -> T
        xs := self

        while n > 0
            xs = xs.tail()
            n -= 1

        return xs.head()

    def reverse(self: [T]) -> [T]
        ys := []
        for x in self
            ys = x :: ys

        return ys

    def concat(self: [T], other: [T]) -> [T]
        result := other

        for x in self.reverse()
            result = x :: result

        return result

    def filter(self: [T], f: T -> Bool) -> [T]
        result := []
        for x in self
            if f(x)
                result = x :: result

        return result.reverse()

    def map<S>(self: [T], f: T -> S) -> [S]
        result := []
        for x in self
            result = f(x) :: result

        return result.reverse()


## Range ##
struct Range<T: Num>
    start: T
    end: T

def range<T: Num>(start: T, end: T) -> Range<T>
    return Range(start, end)

impl<T: Num> Range<T>
    def head(self: Range<T>) -> T
        assert self.start < self.end
        return self.start

    def tail(self: Range<T>) -> Range<T>
        assert self.start < self.end
        return Range(self.start + 1, self.end)

    def empty(self: Range<T>) -> Bool
        return self.start >= self.end

    def toList(self: Range<T>) -> [T]
        result := []

        if self.empty()
            return result

        i := self.end - 1
        while i >= self.start
            result = i :: result
            i -= 1

        return result


## Native-language standard library
def assertMessage(b: Bool, err: String) -> Unit
    if not b
        panic $ "Assertion failed: " ++ err


def drop<T>(x: T) -> Unit
    pass


def sum<T: Num>(xs: [T]) -> T
    result := 0
    for x in xs
        result += x

    return result


def product<T: Num>(xs: [T]) -> T
    if xs.empty()
        return 1
    else
        return xs.head() * product(xs.tail())


def max<T: Num>(a: T, b: T) -> T
    if a > b
        return a
    else
        return b


def min<T: Num>(a: T, b: T) -> T
    if a < b
        return a
    else
        return b


def maximum<T: Num>(xs: [T]) -> T
    if xs.length() == 1
        return xs.head()
    else
        return max(xs.head(), maximum(xs.tail()))


def minimum<T: Num>(xs: [T]) -> T
    if xs.length() == 1
        return xs.head()
    else
        return min(xs.head(), minimum(xs.tail()))


def even<T: Num>(x: T) -> Bool
    if x mod 2 == 0
        return True
    else
        return False


def odd<T: Num>(x: T) -> Bool
    if x mod 2 == 0
        return False
    else
        return True


def pow<T: Num>(a: T, b: UInt) -> T
    r := 1
    forever
        if b mod 2 == 1
            r *= a

        b /= 2

        if b == 0
            break

        a *= a

    return r


## Pair ##
data Pair<S, T> = Pair(S, T)

impl<S, T> Pair<S, T>
    def first(self: Pair<S, T>) -> S
        match self
            Pair(x, _) => return x

    def second(self: Pair<S, T>) -> T
        match self
            Pair(_, x) => return x


def splitAt<T>(n: UInt, xs: [T]) -> Pair<[T], [T]>
    return Pair(xs.take(n), xs.drop(n))


## Ord trait ##
data Ordering = Less | Equal | Greater

trait Ord
    def cmp(self: Self, other: Self) -> Ordering

impl Ord for Int
    def cmp(self: Int, other: Int) -> Ordering
        if self < other
            return Less
        elif self > other
            return Greater
        else
            return Equal

impl Ord for UInt
    def cmp(self: UInt, other: UInt) -> Ordering
        if self < other
            return Less
        elif self > other
            return Greater
        else
            return Equal

impl<T: Ord> Ord for [T]
    def cmp(self: [T], other: [T]) -> Ordering
        if self.empty()
            if other.empty()
                return Equal
            else
                return Less
        elif other.empty()
            return Greater
        else
            match self.head().cmp(other.head())
                Less
                    return Less
                Greater
                    return Greater
                Equal
                    return self.tail().cmp(other.tail())

impl Ord for String
    def cmp(self: String, other: String) -> Ordering
        n1 := self.length()
        n2 := other.length()

        for n in range(0, min(n1, n2) + 1)
            if self.length() <= n
                if other.length() <= n
                    return Equal
                else
                    return Less
            elif other.length() <= n
                return Greater
            else
                if self.at(n) < other.at(n)
                    return Less
                elif self.at(n) > other.at(n)
                    return Greater

        panic $ "Unreachable"


## Eq trait ##
trait Eq
    def eq(lhs: Self, rhs: Self) -> Bool

impl Eq for Int
    def eq(lhs: Int, rhs: Int) -> Bool
        return lhs == rhs

impl Eq for String
    def eq(lhs: String, rhs: String) -> Bool
        n1 := lhs.length()
        n2 := rhs.length()

        if n1 != n2
            return False

        for i in range(0, n1)
            if lhs.at(i) != rhs.at(i)
                return False

        return True

impl<T: Eq> Eq for [T]
    def eq(self: [T], other: [T]) -> Bool
        if self.empty()
            return other.empty()
        elif other.empty()
            return False

        if not self.head().eq(other.head())
            return False
        else
            return self.tail().eq(other.tail())


## Hash trait ##
trait Hash
    def hash(self: Self) -> UInt

impl Hash for Int
    def hash(self: Int) -> UInt
        return self as UInt

impl Hash for String
    def hash(self: String) -> UInt
        return strHash(self)

data List<T> = Cons(T, List<T>) | Nil

## String ##
type Char = Int
foreign strLength(s: String) -> Int
foreign strSlice(s: String, pos: Int, len: Int) -> String
foreign strAt(s: String, n: Int) -> Char
foreign strFromList(s: [Char]) -> String
foreign strCat(lhs: String, rhs: String) -> String
foreign show(x: Int) -> String

## Array ##
foreign makeArray<T>(n: Int, value: T) -> Array<T>
foreign arrayAt<T>(arr: Array<T>, n: Int) -> T
foreign arraySet<T>(arr: Array<T>, n: Int, value: T) -> Unit


foreign die<T>(msg: String) -> T

## Option ##
data Option<T> = Some(T) | None

def isSome<T>(x: Option<T>) -> Bool
    match x
        Some(_) => return True
        None   => return False

def isNone<T>(x: Option<T>) -> Bool
    match x
        Some(_) => return False
        None   => return True

def unwrap<T>(x: Option<T>) -> T
    match x
        Some(y) => return y
        None   => die("*** Exception: Cannot unwrap None")

def unwrapOr<T>(x: Option<T>, other: T) -> T
    match x
        Some(y) => return y
        None   => return other

# I/O functions
foreign read() -> Int
foreign readLine() -> Option<String>
foreign print(msg: String) -> Unit

# Basic List operations
def head<T>(xs: [T]) -> T
    match xs
        Cons(x, _) => return x
        Nil        => die("*** Exception: Called head on empty list")

def tail<T>(xs: [T]) -> [T]
    match xs
        Cons(_, rest) => return rest
        Nil           => die("*** Exception: Called tail on empty list")

def null<T>(xs: [T]) -> Bool
    match xs
        Cons(_, _) => return False
        Nil        => return True

## Native-language standard library

def concat<T>(xs: [T], ys: [T]) -> [T]
    if null(xs)
        return ys
    else
        return head(xs) :: concat(tail(xs), ys)


def assert(b: Bool) -> Unit
    if not(b)
        die("*** Exception: Assertion failed")


def assertMessage(b: Bool, err: String) -> Unit
    if not(b)
        die("*** Exception: Assertion failed: " ^ err)


# Miscellanous functions
def range(a: Int, b: Int) -> [Int]
    xs := []

    i := b
    while i >= a
        xs = i :: xs
        i -= 1

    return xs


def length<T>(xs: [T]) -> Int
    result := 0

    while not(null(xs))
        xs = tail(xs)
        result += 1

    return result


def sum(xs: [Int]) -> Int
    result := 0
    for x in xs
        result += x

    return result


def product(xs: [Int]) -> Int
    if null(xs)
        return 1
    else
        return head(xs) * product(tail(xs))


def take<T>(n: Int, xs: [T]) -> [T]
    if n == 0
        return []
    else
        return head(xs) :: take(n - 1, tail(xs))


def drop<T>(n: Int, xs: [T]) -> [T]
    if n == 0
        return xs
    else
        return drop(n - 1, tail(xs))


def max(a: Int, b: Int) -> Int
    if a > b
        return a
    else
        return b


def min(a: Int, b: Int) -> Int
    if a < b
        return a
    else
        return b


def maximum(xs: [Int]) -> Int
    if length(xs) == 1
        return head(xs)
    else
        return max(head(xs), maximum(tail(xs)))


def minimum(xs: [Int]) -> Int
    if length(xs) == 1
        return head(xs)
    else
        return min(head(xs), minimum(tail(xs)))


def at<T>(n: Int, xs: [T]) -> T
    while n > 0
        xs = tail(xs)
        n -= 1

    return head(xs)


def reverse<T>(xs: [T]) -> [T]
    ys := []
    for x in xs
        ys = x :: ys

    return ys


def map<S, T>(f: S -> T, xs: [S]) -> [T]
    result := []
    for x in xs
        result = f(x) :: result

    return reverse(result)


def filter<T>(f: T -> Bool, xs: [T]) -> [T]
    ys := []
    for x in xs
        if f(x)
            ys = x :: ys

    return reverse(ys)


def even(x: Int) -> Bool
    if x mod 2 == 0
        return True
    else
        return False


def odd(x: Int) -> Bool
    if x mod 2 == 0
        return False
    else
        return True


def pow(a: Int, b: Int) -> Int
    r := 1
    forever
        if b mod 2 == 1
            r *= a

        b /= 2

        if b == 0
            break

        a *= a

    return r


# Non stack-destroying version
#def concat xs ys :: [Int] -> [Int] -> [Int]
#    let zs :: [Int] := ys

#    for x in reverse xs
#        zs = x :: zs

#    return zs


## Pairs ##

data Pair<T> = Pair(T, T)


def fst<T>(pair: Pair<T>) -> T
    let Pair(x, _) := pair
    return x


def snd<T>(pair: Pair<T>) -> T
    let Pair(_, x) := pair
    return x


def splitAt<T>(n: Int, xs: [T]) -> Pair<[T]>
    return Pair(take(n, xs), drop(n, xs))

data List a = Cons a (List a) | Nil

# String functions
type Char = Int
foreign strLength(s: String) -> Int
foreign strSlice(s: String, pos: Int, len: Int) -> String
foreign strAt(s: String, n: Int) -> Char
foreign strFromList(s: [Char]) -> String
foreign strCat(lhs: String, rhs: String) -> String
foreign show(x: Int) -> String

foreign die(msg: String) -> a

## Option ##
data Option a = Some a | None

def isSome(x: Option a) -> Bool
    match x
        Some _ => return True
        None   => return False

def isNone(x: Option a) -> Bool
    match x
        Some _ => return False
        None   => return True

def unwrap(x: Option a) -> a
    match x
        Some y => return y
        None   => die "*** Exception: Cannot unwrap None"

def unwrapOr(x: Option a, other: a) -> a
    match x
        Some y => return y
        None   => return other

# I/O functions
foreign read() -> Int
foreign readLine() -> Option String
foreign print(msg: String) -> Unit

# Basic List operations
def head(xs: [a]) -> a
    match xs
        Cons x _ => return x
        Nil      => die "*** Exception: Called head on empty list"

def tail(xs: [a]) -> [a]
    match xs
        Cons _ rest => return rest
        Nil         => die "*** Exception: Called tail on empty list"

def null(xs: [a]) -> Bool
    match xs
        Cons _ _ => return False
        Nil      => return True

## Native-language standard library

def concat(xs: [a], ys: [a]) -> [a]
    if null xs
        return ys
    else
        return head xs :: concat (tail xs) ys


def assert(b: Bool) -> Unit
    if not b: die "*** Exception: Assertion failed"


def assertMessage(b: Bool, err: String) -> Unit
    if not b: die $ "*** Exception: Assertion failed: " . err


# Miscellanous functions
def range(a: Int, b: Int) -> [Int]
    xs := []

    i := b
    while i >= a
        xs = i :: xs
        i -= 1

    return xs


def length(xs: [a]) -> Int
    result := 0

    while not $ null xs
        xs = tail xs
        result += 1

    return result


def sum(xs: [Int]) -> Int
    if null xs
        return 0
    else
        return head xs + sum $ tail xs


def product(xs: [Int]) -> Int
    if null xs
        return 1
    else
        return head xs * product $ tail xs


def take(n: Int, xs: [a]) -> [a]
    if n == 0
        return []
    else
        return head xs :: take (n - 1) (tail xs)


def drop(n: Int, xs: [a]) -> [a]
    if n == 0
        return xs
    else
        return drop (n - 1) (tail xs)


def max(a: Int, b: Int) -> Int
    if a > b
        return a
    else
        return b


def min(a: Int, b: Int) -> Int
    if a < b
        return a
    else
        return b


def maximum(xs: [Int]) -> Int
    if length xs == 1
        return head xs
    else
        return max (head xs) (maximum $ tail xs)


def at(n: Int, xs: [a]) -> a
    while n > 0
        xs = tail xs
        n -= 1

    return head xs


def reverse(xs: [a]) -> [a]
    ys := []
    for x in xs
        ys = x :: ys

    return ys


def map(f: a -> b, xs: [a]) -> [b]
    result := []
    for x in xs
        result = f x :: result

    return reverse result


def filter(f: a -> Bool, xs: [a]) -> [a]
    ys := []
    for x in xs
        if f x: ys = x :: ys

    return reverse ys


def even(x: Int) -> Bool
    if x mod 2 == 0: return True
    else: return False


def odd(x: Int) -> Bool
    if x mod 2 == 0: return False
    else: return True


def pow(a: Int, b: Int) -> Int
    r := 1
    while True
        if b mod 2 == 1: r *= a
        b /= 2
        if b == 0: break
        a *= a

    return r


# Non stack-destroying version
#def concat xs ys :: [Int] -> [Int] -> [Int]
#    let zs :: [Int] = ys

#    for x in reverse xs
#        zs = x :: zs

#    return zs


## Pairs ##

data Pair a = Pair a a


def fst(pair: Pair a) -> a
    let Pair x _ = pair
    return x


def snd(pair: Pair a) -> a
    let Pair _ x = pair
    return x


def splitAt(n: Int, xs: [a]) -> Pair [a]
    return Pair (take n xs) (drop n xs)

data BigInt = BigInt([Int])

def toBigInt(x: Int) -> BigInt
    result := []

    while x != 0
        result = (x mod 10) :: result
        x /= 10

    return BigInt(result.reverse())

impl BigInt
    def digits(self: BigInt) -> [Int]
        let BigInt(xs) := self
        return xs

    def plus(self: BigInt, rhs: BigInt) -> BigInt
        xs := self.digits()
        ys := rhs.digits()

        carry := 0
        result := []

        x := 0
        y := 0
        while not (xs.empty() and ys.empty() and carry == 0)
            if xs.empty()
                x = 0
            else
                x = xs.head()
                xs = xs.tail()

            if ys.empty()
                y = 0
            else
                y = ys.head()
                ys = ys.tail()

            z := x + y + carry

            result = (z mod 10) :: result
            carry = z / 10

        return BigInt(result.reverse())

    def timesInt(self: BigInt, rhs: Int) -> BigInt
        xs := self.digits()

        carry := 0
        result := []

        while not(xs.empty() and carry == 0)
            z := 0
            if xs.empty()
                z = carry
            else
                x := xs.head()
                z = x * rhs + carry
                xs = xs.tail()

            result = (z mod 10) :: result
            carry = z / 10

        return BigInt(result.reverse())

    def shift(self: BigInt, n: Int) -> BigInt
        if n == 0
            return self
        else
            newDigits := self.digits()
            for i = 1 to n
                newDigits = 0 :: newDigits

            return BigInt(newDigits)

    def times(self: BigInt, rhs: BigInt) -> BigInt
        ys := rhs.digits()

        result := toBigInt(0)
        for n in urange(0, ys.length() - 1)
            y := ys.at(n)
            z1 := self.timesInt(y)
            z2 := z1.shift(n)

            result = result.plus(z2)

        return result

    def toString(self: BigInt) -> String
        s := []
        for x in self.digits()
            s = (x + '0') :: s

        return strFromList(s)

# Computes a^b
def bigPower(a: Int, b: Int) -> BigInt
    bigA := toBigInt(a)
    result := toBigInt(1)

    for i = 1 to b
        result = result.times(bigA)

    return result

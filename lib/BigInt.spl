data BigInt = BigInt([Int])

def toBigInt(x: Int) -> BigInt
    result := []

    while x != 0
        result = (x mod 10) :: result
        x /= 10

    return BigInt(reverse(result))

impl BigInt
    def digits(self: BigInt) -> [Int]
        let BigInt(xs) := self
        return xs

    def plus(self: BigInt, rhs: BigInt) -> BigInt
        xs := self.digits()
        ys := rhs.digits()

        carry := 0
        result := []

        x := 0
        y := 0
        while not(null(xs) and null(ys) and carry == 0)
            if null(xs)
                x = 0
            else
                x = head(xs)
                xs = tail(xs)

            if null(ys)
                y = 0
            else
                y = head(ys)
                ys = tail(ys)

            z := x + y + carry

            result = (z mod 10) :: result
            carry = z / 10

        return BigInt(reverse(result))

    def timesInt(self: BigInt, rhs: Int) -> BigInt
        xs := self.digits()

        carry := 0
        result := []

        while not(null(xs) and carry == 0)
            z := 0
            if null(xs)
                z = carry
            else
                x := head(xs)
                z = x * rhs + carry
                xs = tail(xs)

            result = (z mod 10) :: result
            carry = z / 10

        return BigInt(reverse(result))

    def shift(self: BigInt, n: Int) -> BigInt
        if n == 0
            return self
        else
            newDigits := self.digits()
            for i = 1 to n
                newDigits = 0 :: newDigits

            return BigInt(newDigits)

    def times(self: BigInt, rhs: BigInt) -> BigInt
        ys := rhs.digits()

        partialProducts := []

        result := toBigInt(0)
        for n = 0 to length(ys) - 1
            y := at(n, ys)
            z1 := self.timesInt(y)
            z2 := z1.shift(n)

            result = result.plus(z2)

        return result

    def toString(self: BigInt) -> String
        s := []
        for x in self.digits()
            s = (x + '0') :: s

        return strFromList(s)

# Computes a^b
def bigPower(a: Int, b: Int) -> BigInt
    bigA := toBigInt(a)
    result := toBigInt(1)

    for i = 1 to b
        result = result.times(bigA)

    return result

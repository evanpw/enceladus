struct HashTable<S: Eq + Hash, T>
    contents: Array<Option<Pair<S, T>>>
    size: UInt
    capacity: UInt

impl HashTable<S, T>
    def new() -> HashTable<S, T>
        return HashTable(Array::make(0, None), 0, 0)

    def insert(self, key: S, value: T) -> Unit
        # Resize when 2/3 full
        if 3 * self.size >= 2 * self.capacity
            newCapacity := max(1, 3 * self.size)
            self.resize(newCapacity)

        startIdx := key.hash() % self.capacity

        # Linear probing
        idx := startIdx
        forever
            match self.contents[idx]
                Some(item)
                    let Pair(k, v) := item

                    if k == key
                        self.contents.set(idx, Some(Pair(key, value)))
                        break

                None
                    self.contents.set(idx, Some(Pair(key, value)))
                    break

            idx = (idx + 1) % self.capacity

        self.size += 1

    def get(self, key: S) -> Option<T>
        if self.capacity == 0
            return None

        startIdx := key.hash() % self.capacity

        idx := startIdx
        forever
            match self.contents[idx]
                Some(item)
                    let Pair(k, v) := item

                    if k == key
                        return Some(v)

                None
                    return None

            idx = (idx + 1) % self.capacity
            if idx == startIdx
                return None

    def resize(self, newCapacity: UInt) -> Unit
        assert newCapacity >= self.size

        oldContents := self.contents
        oldCapacity := self.capacity

        self.capacity = newCapacity
        self.contents = Array::make(newCapacity, None)
        self.size = 0

        for idx in range(0, oldCapacity)
            match oldContents[idx]
                Some(item)
                    let Pair(k, v) := item
                    self.insert(k, v)
                None
                    pass

impl Index<S, Option<T>> for HashTable<S, T>
    def at(self, key: S) -> Option<T>
        return self.get(key)

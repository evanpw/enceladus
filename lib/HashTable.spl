struct HashTable<S: Eq + Hash, T>
    contents: Array<Option<Pair<S, T>>>
    size: UInt
    capacity: UInt

impl<S: Eq + Hash, T> HashTable<S, T>
    def new() -> HashTable<S, T>
        return HashTable(makeArray(0, None), 0, 0)

    def insert(self: HashTable<S, T>, key: S, value: T) -> Unit
        # Resize when 2/3 full
        if 3 * self.size >= 2 * self.capacity
            newCapacity := max(1, 3 * self.size)
            self.resize(newCapacity)

        startIdx := key.hash() mod self.capacity

        # Linear probing
        idx := startIdx
        forever
            match self.contents[idx]
                Some(item)
                    let Pair(k, v) := item

                    if k.eq(key)
                        self.contents.set(idx, Some(Pair(key, value)))
                        break

                None
                    self.contents.set(idx, Some(Pair(key, value)))
                    break

            idx = (idx + 1) mod self.capacity

        self.size += 1

    def get(self: HashTable<S, T>, key: S) -> Option<T>
        if self.capacity == 0
            return None

        startIdx := key.hash() mod self.capacity

        idx := startIdx
        forever
            match self.contents[idx]
                Some(item)
                    let Pair(k, v) := item

                    if k.eq(key)
                        return Some(v)

                None
                    return None

            idx = (idx + 1) mod self.capacity
            if idx == startIdx
                return None

    def resize(self: HashTable<S, T>, newCapacity: UInt) -> Unit
        assert newCapacity >= self.size

        oldContents := self.contents
        oldCapacity := self.capacity

        self.capacity = newCapacity
        self.contents = makeArray(newCapacity, None)
        self.size = 0

        for idx in range(0, oldCapacity)
            match oldContents[idx]
                Some(item)
                    let Pair(k, v) := item
                    self.insert(k, v)
                None
                    pass

impl<S: Eq + Hash, T> Index<S, Option<T>> for HashTable<S, T>
    def at(self: HashTable<S, T>, key: S) -> Option<T>
        return self.get(key)

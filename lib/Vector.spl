struct Vector<T>
    content: Array<Option<T>>
    capacity: Int
    size: Int

def vector<T>() -> Vector<T>
    return Vector(emptyArray(), 0, 0)

impl<T> Vector<T>
    def pushBack(self: Vector<T>, x: T) -> Unit
        if self.size < self.capacity
            self.content.set(self.size, Some(x))
            self.size += 1
        else
            newCapacity := self.capacity * 2 + 1
            newContent := makeArray(newCapacity, None)
            for i = 0 to self.size - 1
                newContent.set(i, self.content[i])

            newContent.set(self.size, Some(x))

            self.content = newContent
            self.capacity = newCapacity
            self.size += 1

    def popBack(self: Vector<T>) -> T
        assert self.size > 0
        value := self.content[self.size - 1]
        self.size -= 1

        return value.unwrap()

    def at(self: Vector<T>, n: Int) -> T
        return self.content.at(n).unwrap()

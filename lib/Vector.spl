struct Vector<T: Default>
    content: Array<T>
    capacity: UInt
    size: UInt

struct VectorIterator<T: Default>
    v: Vector<T>
    idx: UInt

impl<T: Default> Vector<T>
    def new() -> Vector<T>
        return Vector(Array::new(), 0, 0)

    def append(self: Vector<T>, x: T) -> Unit
        if self.size < self.capacity
            self.content.set(self.size, x)
            self.size += 1
        else
            newCapacity := self.capacity * 2 + 1
            newContent := Array::make(newCapacity, T::default())
            for i in range(0, self.size)
                newContent.set(i, self.content[i])

            newContent.set(self.size, x)

            self.content = newContent
            self.capacity = newCapacity
            self.size += 1

    def pop(self: Vector<T>) -> T
        assert self.size > 0
        value := self.content[self.size - 1]
        self.size -= 1

        return value

    def set(self: Vector<T>, n: UInt, x: T) -> Unit
        self.content.set(n, x)

    def copy(self: Vector<T>) -> Vector<T>
        result := Vector(Array::make(self.capacity, T::default()), self.capacity, self.size)
        for i in range(0, self.size)
            result.content.set(i, self.content[i])

        return result

    def iter(self: Vector<T>) -> VectorIterator<T>
        return VectorIterator(self, 0)

impl<T: Default> Index<UInt, T> for Vector<T>
    def at(self: Vector<T>, n: UInt) -> T
        return self.content[n]

impl<T: Default> Iterator<T> for VectorIterator<T>
    def head(self: VectorIterator<T>) -> T
        assert self.idx < self.v.size
        return self.v.at(self.idx)

    def tail(self: VectorIterator<T>) -> VectorIterator<T>
        return VectorIterator(self.v, self.idx + 1)

    def empty(self: VectorIterator<T>) -> Bool
        return self.idx >= self.v.size

def all(xs: Vector<Bool>) -> Bool
    for x in xs.iter()
        if not x
            return False

    return True

def any(xs: Vector<Bool>) -> Bool
    for x in xs.iter()
        if x
            return True

    return False

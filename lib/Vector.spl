struct Vector<T: Default>
    content: Array<T>
    capacity: UInt
    size: UInt


impl<T: Default> Vector<T>
    def new() -> Vector<T>
        return Vector(emptyArray(), 0, 0)

    def append(self: Vector<T>, x: T) -> Unit
        if self.size < self.capacity
            self.content.set(self.size, x)
            self.size += 1
        else
            newCapacity := self.capacity * 2 + 1
            newContent := makeArray(newCapacity, T::default())
            for i in range(0, self.size)
                newContent.set(i, self.content[i])

            newContent.set(self.size, x)

            self.content = newContent
            self.capacity = newCapacity
            self.size += 1

    def pop(self: Vector<T>) -> T
        assert self.size > 0
        value := self.content[self.size - 1]
        self.size -= 1

        return value

    def at(self: Vector<T>, n: UInt) -> T
        return self.content.at(n)

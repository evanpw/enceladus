struct Vector<T: Default>
    content: Array<T>
    size: UInt

struct VectorIterator<T: Default>
    v: Vector<T>
    idx: UInt

impl Vector<T>
    def new() -> Vector<T>
        return Vector(Array::new(), 0)

    def append(self, x: T)
        if self.size < self.content.length()
            self.content.set(self.size, x)
            self.size += 1
        else
            newCapacity := self.content.length() * 2 + 1
            newContent := Array::make(newCapacity, T::default())
            for i in range(0, self.size)
                newContent.set(i, self.content[i])

            newContent.set(self.size, x)

            self.content = newContent
            self.size += 1

    def pop(self) -> T
        assert self.size > 0
        value := self.content[self.size - 1]
        self.size -= 1

        return value

    def set(self, n: UInt, x: T)
        self.content.set(n, x)

    def toArray(self) -> Array<T>
        result := Array::make(self.size, T::default())
        for i in range(0, self.size)
            result.set(i, self.content[i])

        return result

    def copy(self) -> Vector<T>
        return Vector(self.toArray(), self.size)

    def iter(self) -> VectorIterator<T>
        return VectorIterator(self, 0)

    def length(self) -> UInt
        return self.size

impl Index<UInt, T> for Vector<T>
    def at(self, n: UInt) -> T
        return self.content[n]

impl Iterator<T> for VectorIterator<T>
    def head(self) -> T
        assert self.idx < self.v.size
        return self.v.at(self.idx)

    def tail(self) -> VectorIterator<T>
        return VectorIterator(self.v, self.idx + 1)

    def empty(self) -> Bool
        return self.idx >= self.v.size

def all(xs: Vector<Bool>) -> Bool
    for x in xs.iter()
        if not(x)
            return False

    return True

def any(xs: Vector<Bool>) -> Bool
    for x in xs.iter()
        if x
            return True

    return False

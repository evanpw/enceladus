# TopCoder SRM 667, Round 1, Problem 1

# Ideas:
# LANG: Add a python-style list to the language (maybe replace current list type)
# LANG: Add bit operations to the language
# LIB: Create a string that consists of a repeated character
# LIB: Replace a specific slice of a string
# LANG: Iterator that generalizes String and List and can be looped over
# TST: Add tests for library functions
# LANG: Make destructuring look more like a normal variable definition?
# LIB: Deque data structure
# LANG: Set array elements using the same array[offset] syntax as getting
# LANG: Add continue keyword
# LIB: String comparison

import List
import HashTable

def simulateInstruction(cache: String, inst: String) -> Pair<String, Int>
    newCache := []
    k := 0

    for i = 0 to cache.length() - 1
        c := cache[i]
        x := inst[i]

        if c == '0' and x == '1'
            c = '1'
            k += 1

        newCache = c :: newCache

    return Pair(strFromList(newCache.reverse()), k * k)

def zeroCache(m: Int) -> String
    result := ""
    for i = 1 to m
        result = result ++ "0"

    return result

def fullCache(instructions: [String]) -> String
    m := instructions.head().length()
    cache := zeroCache(m)

    for inst in instructions
        cache = simulateInstruction(cache, inst).first()

    return cache

# Return a string that differs from the given one by setting location n to
# the character '0'
def zeroBit(cache: String, n: Int) -> String
    len := cache.length()

    if n == 0
        return "0" ++ cache.slice(1, len - 1)
    else
        return cache.slice(0, n - 1) ++ "0" ++ cache.slice(n + 1, len - n - 1)

# Determine all cache strings that can be obtained from the given one by
# removing a single bit
def predecessors(cache: String) -> [String]
    result := []

    for i = 0 to cache.length() - 1
        if cache[i] == '1'
            result = zeroBit(cache, i) :: result

    return result

def costAt(memo: HashTable<String, Int>, instructions: [String], cache: String) -> Int
    savedValue := memo.get(cache)
    if savedValue.isSome()
        return savedValue.unwrap()

    # Examine each successor of this cache value
    costs := []
    for inst in instructions
        let Pair(nextCache, instCost) := simulateInstruction(cache, inst)

        if cmpString(cache, nextCache) != 0
            # The min cost starting at this point is at most the cost of this
            # instruction, plus the cost starting at the successor cache value
            cost := instCost + costAt(memo, instructions, nextCache)
            costs = cost :: costs

    assert costs.length() > 0

    bestCost := minimum(costs)
    memo.insert(cache, bestCost)

    return bestCost

def minTime(instructions: [String]) -> Int
    n := instructions.length()
    m := instructions.head().length()

    empty := zeroCache(m)
    full := fullCache(instructions)
    memo := hashTable(hashString, eqString)

    # From a full cache, we're finished -> zero time
    memo.insert(full, 0)

    return costAt(memo, instructions, empty)


assert minTime(["111", "001", "010"]) == 3
assert minTime(["11101", "00111", "10101", "00000", "11000"]) == 9
assert minTime(["11111111111111111111"]) == 400
assert minTime(["1000", "1100", "1110"]) == 3
assert minTime(["111", "111", "110", "100"]) == 3

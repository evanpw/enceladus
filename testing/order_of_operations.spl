# TopCoder SRM 667, Round 1, Problem 1

# Ideas:
# LANG: Make assert statements print out the location of failure
# LANG: Add a python-style list to the language (maybe replace current list type)
# LANG: Add bit operations to the language
# LIB: Create a string that consists of a repeated character
# LIB: Replace a specific slice of a string
# LANG: Iterator that generalizes String and List and can be looped over
# TST: Add tests for library functions
# LANG: Syntactic sugar for String.at
# LANG: Make destructuring look more like a normal variable definition?
# LIB: Deque data structure
# LANG: Set array elements using the same array.[offset] syntax as getting
# LANG: Add continue keyword
# LIB: String comparison

import List

data InstResult = InstResult(String, Int)

def simulateInstruction(cache: String, inst: String) -> InstResult
    newCache := []
    k := 0

    for i = 0 to cache.length() - 1
        c := cache.at(i)
        x := inst.at(i)

        if c == '0' and x == '1'
            c = '1'
            k += 1

        newCache = c :: newCache

    return InstResult(strFromList(newCache.reverse()), k * k)

def zeroCache(m: Int) -> String
    result := ""
    for i = 1 to m
        result = result ^ "0"

    return result

def fullCache(instructions: [String]) -> String
    m := instructions.head().length()
    cache := zeroCache(m)

    for inst in instructions
        let InstResult(newCache, _) := simulateInstruction(cache, inst)
        cache = newCache

    return cache

def cacheToOffset(cache: String) -> Int
    offset := 0
    for i = 0 to cache.length() - 1
        c := cache.at(i)

        offset *= 2
        if c == '1'
            offset += 1

    return offset

def hasValue(memo: Array<Int>, cache: String) -> Bool
    offset := cacheToOffset(cache)
    value := memo.[offset]

    return value != -1

def getValue(memo: Array<Int>, cache: String) -> Int
    offset := cacheToOffset(cache)
    value := memo.[offset]

    assert(value != -1)

    return value

def setValue(memo: Array<Int>, cache: String, value: Int) -> Unit
    offset := cacheToOffset(cache)
    assert(memo.[offset] == -1)
    memo.set(offset, value)

# Return a string that differs from the given one by setting location n to
# the character '0'
def zeroBit(cache: String, n: Int) -> String
    len := cache.length()

    if n == 0
        return "0" ^ cache.slice(1, len - 1)
    else
        return cache.slice(0, n - 1) ^ "0" ^ cache.slice(n + 1, len - n - 1)

# Determine all cache strings that can be obtained from the given one by
# removing a single bit
def predecessors(cache: String) -> [String]
    result := []

    for i = 0 to cache.length() - 1
        if cache.at(i) == '1'
            result = zeroBit(cache, i) :: result

    return result

def costAt(memo: Array<Int>, instructions: [String], cache: String) -> Int
    if hasValue(memo, cache)
        return getValue(memo, cache)

    # Examine each successor of this cache value
    costs := []
    for inst in instructions
        let InstResult(nextCache, instCost) := simulateInstruction(cache, inst)

        if cmpString(cache, nextCache) != 0
            # The min cost starting at this point is at most the cost of this
            # instruction, plus the cost starting at the successor cache value
            cost := instCost + costAt(memo, instructions, nextCache)
            costs = cost :: costs

    assert(costs.length() > 0)

    bestCost := minimum(costs)
    setValue(memo, cache, bestCost)

    return bestCost

def minTime(instructions: [String]) -> Int
    n := instructions.length()
    m := instructions.head().length()

    empty := zeroCache(m)
    full := fullCache(instructions)
    memo := makeArray(pow(2, m), -1)

    # From a full cache, we're finished -> zero time
    setValue(memo, full, 0)

    return costAt(memo, instructions, empty)


assert(minTime(["111", "001", "010"]) == 3)
assert(minTime(["11101", "00111", "10101", "00000", "11000"]) == 9)
assert(minTime(["11111111111111111111"]) == 400)
assert(minTime(["1000", "1100", "1110"]) == 3)
assert(minTime(["111", "111", "110", "100"]) == 3)

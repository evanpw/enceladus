# Brainfuck interpreter
# see https://en.wikipedia.org/wiki/Brainfuck
import IO


struct State
    memory: Array<UInt8>
    dp: UInt
    ip: UInt


impl State
    def new(memSize: UInt) -> State
        arr := Array::make(memSize, 0)
        return State(arr, 0, 0)


# IR Instructions
data Instruction = Add(UInt) | Sub(UInt) | Right(UInt) | Left(UInt) | Out | In | Open | Close | Clear

# Should be able to derive these for simple types
impl Default for Instruction
    def default() -> Instruction
        return Add(0)

# This is all horrendously ugly
impl Instruction
    def isSub(self: Instruction) -> Bool
        match self
            Sub(_) => return True
            Else   => return False

    def isAdd(self: Instruction) -> Bool
        match self
            Add(_) => return True
            Else   => return False

    def isOpen(self: Instruction) -> Bool
        match self
            Open    => return True
            Else    => return False

    def isClose(self: Instruction) -> Bool
        match self
            Close    => return True
            Else     => return False


def compile(program: String) -> Vector<Instruction>
    result := Vector::new()

    for c in program.iter()
        if c == '+'
            result.append(Add(1))

        elif c == '-'
            result.append(Sub(1))

        elif c == '>'
            result.append(Right(1))

        elif c == '<'
            result.append(Left(1))

        elif c == '.'
            result.append(Out)

        elif c == ','
            result.append(In)

        elif c == '['
            result.append(Open)

        elif c == ']'
            result.append(Close)

    return result

def optimize1(program: Vector<Instruction>) -> Vector<Instruction>
    if program.length() == 0
        return program

    result := Vector::new()

    # Convert [-] and [+] to Clear
    i := 0
    while i < program.length()
        if i + 2 < program.length() and program[i].isOpen() and program[i + 2].isClose()
            if program[i + 1].isSub() or program[i + 1].isAdd()
                result.append(Clear)
                i += 3
                continue

        result.append(program[i])
        i += 1

    return result

def optimize2(program: Vector<Instruction>) -> Vector<Instruction>
    if program.length() == 0
        return program

    result := Vector::new()
    result.append(program[0])

    # Combine repeated +, -, <, or > instructions
    for i in range(1, program.length())
        last := result[result.length() - 1]

        match program[i]
            Add(n)
                match last
                    Add(m)
                        result[result.length() - 1] = Add(n + m)
                    Else
                        result.append(program[i])
            Sub(n)
                match last
                    Sub(m)
                        result[result.length() - 1] = Sub(n + m)
                    Else
                        result.append(program[i])
            Right(n)
                match last
                    Right(m)
                        result[result.length() - 1] = Right(n + m)
                    Else
                        result.append(program[i])
            Left(n)
                match last
                    Left(m)
                        result[result.length() - 1] = Left(n + m)
                    Else
                        result.append(program[i])
            Else
                result.append(program[i])

    return result

def step(state: State, program: Vector<Instruction>)
    match program[state.ip]
        Add(n)
            state.memory[state.dp] += n as UInt8

        Sub(n)
            state.memory[state.dp] -= n as UInt8

        Right(n)
            state.dp += n
            assert state.dp < state.memory.length()

        Left(n)
            assert state.dp >= n
            state.dp -= n

        Out
            putchar(state.memory[state.dp])

        In
            match readChar(stdin)
                Some(c)
                    state.memory[state.dp] = c
                None
                    state.memory[state.dp] = -1 as UInt8

        Open
            if state.memory[state.dp] == 0

                matchingBracket := 0
                nesting := 1

                for i in range(state.ip + 1, program.length())
                    if program[i].isOpen()
                        nesting += 1

                    elif program[i].isClose()
                        nesting -= 1
                        if nesting == 0
                            matchingBracket = i
                            break

                assert nesting == 0
                state.ip = matchingBracket + 1
                return

        Close
            if state.memory[state.dp] != 0

                matchingBracket := 0
                nesting := 1

                for i in rangeBy(state.ip - 1, 0, -1)
                    if program[i].isClose()
                        nesting += 1

                    elif program[i].isOpen()
                        nesting -= 1
                        if nesting == 0
                            matchingBracket = i
                            break

                assert nesting == 0
                state.ip = matchingBracket + 1
                return

        Clear
            state.memory[state.dp] = 0

    state.ip += 1


def run(program: Vector<Instruction>)
    state := State::new(30000)

    while state.ip < program.length()
        step(state, program)


argc := getArgc()
if argc < 2
    panic $ "Must specify path of source file"

fname := getArgv(1)

match openFile(fname, "r")
    Some(file)
        source := readAll(file)
        code := compile(source)
        code = optimize2 $ optimize1(code)

        #println $ "Optimized program:"
        #for instruction in code.iter()
        #    match instruction
        #        Add(n)   => println $ "Add " + show(n)
        #        Sub(n)   => println $ "Sub " + show(n)
        #        Right(n) => println $ "Right " + show(n)
        #        Left(n)  => println $ "Left " + show(n)
        #        Out      => println $ "Out"
        #        In       => println $ "In"
        #        Open     => println $ "Open"
        #        Close    => println $ "Close"
        #        Clear    => println $ "Clear"

        run(code)
        closeFile(file)

    None
        panic $ "File not found: '" + fname + "'"

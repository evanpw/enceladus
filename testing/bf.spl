# Brainfuck interpreter
# see https://en.wikipedia.org/wiki/Brainfuck
import IO


struct State
    memory: Array<UInt8>
    dp: UInt
    ip: UInt


impl State
    def new(memSize: UInt) -> State
        arr := Array::make(memSize, 0)
        return State(arr, 0, 0)


# IR Instructions
data Instruction = Add(Int) | MovePtr(Int) | Out | In | Open | Close | Clear

# Should be able to derive these for simple types
impl Default for Instruction
    def default() -> Instruction
        return Add(0)

impl Instruction
    def toString(self: Instruction) -> String
        match self
            Add(m)
                return "Add(" + show(m) + ")"
            MovePtr(m)
                return "MovePtr(" + show(m) + ")"
            Out
                return "Out"
            In
                return "In"
            Open
                return "Open"
            Close
                return "Close"
            Clear
                return "Clear"


struct BetterStringIterator
    str: String
    i: UInt

impl BetterStringIterator
    def next(self: Self) -> Option<Char>
        if self.i >= self.str.length()
            return None
        else
            result := self.str[self.i]
            self.i += 1
            return Some(result)


def compileNext(iter: BetterStringIterator) -> Option<Instruction>
    while let Some(c) := iter.next()
        if c == '+'
            return Some(Add(1))

        elif c == '-'
            return Some(Add(-1))

        elif c == '>'
            return Some(MovePtr(1))

        elif c == '<'
            return Some(MovePtr(-1))

        elif c == '.'
            return Some(Out)

        elif c == ','
            return Some(In)

        elif c == '['
            return Some(Open)

        elif c == ']'
            return Some(Close)

    return None

def compile(program: String) -> Vector<Instruction>
    result := Vector::new()

    iter := BetterStringIterator(program, 0)

    while let Some(inst) := compileNext(iter)
        result.append(inst)

    #for inst in result.iter()
    #    println $ inst.toString()

    return result

def clearLoop(program: Vector<Instruction>) -> Vector<Instruction>
    if program.length() < 3
        return program

    result := Vector::new()
    result.append(program[0])
    result.append(program[1])

    # Convert [-] and [+] to Clear
    for i in range(2, program.length())
        a := program[i - 2]
        b := program[i - 1]
        c := program[i]

        if let Open := a
            if let Close := c
                if let Add(n) := b
                    assert n == 1 or n == -1
                    drop $ result.pop()
                    drop $ result.pop()
                    result.append(Clear)
                    continue

        result.append(c)

    return result

def combineIncrements(program: Vector<Instruction>) -> Vector<Instruction>
    if program.length() == 0
        return program

    result := Vector::new()
    result.append(program[0])

    # Combine repeated +, -, <, or > instructions
    for i in range(1, program.length())
        current := program[i]
        last := result[result.length() - 1]

        if let Add(n) := current
            if let Add(m) := last
                result[result.length() - 1] = Add(n + m)
                continue

        if let MovePtr(n) := current
            if let MovePtr(m) := last
                result[result.length() - 1] = MovePtr(n + m)
                continue

        result.append(program[i])

    return result

def step(state: State, program: Vector<Instruction>)
    match program[state.ip]
        Add(n)
            state.memory[state.dp] += n as UInt8

        MovePtr(n)
            newDP := (state.dp as Int) + n
            assert newDP >= 0 and newDP < state.memory.length() as Int
            state.dp = newDP as UInt

        Out
            putchar(state.memory[state.dp])

        In
            match readChar(stdin)
                Some(c)
                    state.memory[state.dp] = c
                None
                    state.memory[state.dp] = -1 as UInt8

        Open
            if state.memory[state.dp] == 0

                matchingBracket := 0
                nesting := 1

                for i in range(state.ip + 1, program.length())
                    if let Open := program[i]
                        nesting += 1

                    elif let Close := program[i]
                        nesting -= 1
                        if nesting == 0
                            matchingBracket = i
                            break

                assert nesting == 0
                state.ip = matchingBracket + 1
                return

        Close
            if state.memory[state.dp] != 0

                matchingBracket := 0
                nesting := 1

                for i in rangeBy(state.ip - 1, 0, -1)
                    if let Close := program[i]
                        nesting += 1

                    elif let Open := program[i]
                        nesting -= 1
                        if nesting == 0
                            matchingBracket = i
                            break

                assert nesting == 0
                state.ip = matchingBracket + 1
                return

        Clear
            state.memory[state.dp] = 0

    state.ip += 1


def run(program: Vector<Instruction>)
    state := State::new(30000)

    while state.ip < program.length()
        step(state, program)


argc := getArgc()
if argc < 2
    panic $ "Must specify path of source file"

fname := getArgv(1)

match openFile(fname, "r")
    Some(file)
        source := readAll(file)
        code := compile(source)
        code = combineIncrements $ clearLoop(code)

        run(code)
        closeFile(file)

    None
        panic $ "File not found: '" + fname + "'"
